// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { Decimal } from "./Decimal.sol";
import { ERC721A } from "./ERC721A.sol";
import { ERC721AQueryable } from "./ERC721AQueryable.sol";

/**
 * @title A media value system, with perpetual equity to creators
 * @notice This contract provides an interface to mint media.
 */
contract MediaA is ERC721AQueryable, ReentrancyGuard {

    /* *******
     * Globals
     * *******
     */

    // Finalization state, only false can permit mint
    bool public finalization = false;

    string private _contractURI;
    string private _baseTokenURI;

    /* *********
     * Modifiers
     * *********
     */

    /**
     * @notice Require that the token has not been burned and has been minted
     */
    modifier onlyExistingToken(uint256 tokenId) {
        require(_exists(tokenId), "MediaA: nonexistent token");
        _;
    }
    
    /**
     * @notice Ensure that the provided spender is the approved or the owner of
     * the media for the specified tokenId
     */
    modifier onlyApprovedOrOwner(address spender, uint256 tokenId) {
        require(_isApprovedOrOwner(spender, tokenId), "MediaA: Only approved or owner");
        _;
    }

    /**
     * @notice Ensure that the provided URI is not empty
     */
    modifier onlyValidURI(string memory uri) {
        require(bytes(uri).length != 0, "MediaA: specified uri must be non-empty");
        _;
    }

    /**
     * @notice Ensure that the collection of this contract is finalization, and can not mint any more.
     */
    modifier onlyMintAvailable() {
        require(finalization == false, "MediaA: mint function is not available.");
        _;
    }

    /**
     * @notice On deployment, set the media name and symbol
     */
    constructor(string memory _name, string memory _symbol, string memory _uri) ERC721A(_name, _symbol) {
        _baseTokenURI = _uri;
    }

    /* ****************
     * Public Functions
     * ****************
     */

    //https://docs.opensea.io/docs/contract-level-metadata
    function contractURI() public view returns (string memory) {
        return _contractURI;
    }

    function nextTokenId() public view returns (uint256) {
        return _currentIndex;
    }

    /**
     * @notice Burn a token.
     * @dev Only callable if the media owner is also the creator.
     */
    function burn(uint256 tokenId) public
        nonReentrant
        onlyExistingToken(tokenId)
        onlyApprovedOrOwner(_msgSender(), tokenId)
    {
        _burn(tokenId);
    }

    function exists(uint256 tokenId) public view returns (bool) {
        return _exists(tokenId);
    }

    /* ****************
     * External Functions
     * ****************
     */

    function changeContractURI(string memory _uri) external
        onlyOwner
    {
        _contractURI = _uri;
    }

    function mint(uint256 quantity) external
        nonReentrant
    {
        _mintTo(_msgSender(), quantity);
    }

    function mintTo(address to, uint256 quantity) external
        nonReentrant
    {
        _mintTo(to, quantity);
    }

    /**
     * @notice Revoke the approvals for a token. The provided `approve` function is not sufficient
     * for this protocol, as it does not allow an approved address to revoke it's own approval.
     * In instances where a 3rd party is interacting on a user's behalf via `permit`, they should
     * revoke their approval once their task is complete as a best practice.
     */
    function revokeApproval(uint256 tokenId) external
        nonReentrant 
    {
        require(_msgSender() == getApproved(tokenId), "MediaA: caller not approved address");
        approve(address(0), tokenId);
    }

    /**
     * @notice See IMedia
     */
    function finalize() external
        onlyOwner
    {
        require(finalization == false, "Meida: Already finalized");
        finalization = true;
    }

    /* *****************
     * Private Functions
     * *****************
     */

    /**
     * @notice Creates a new token for `creator`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_safeMint}.
     *
     * On mint, also set the sha256 hashes of the content for integrity
     * checks, along with the initial URIs to point to the content. Attribute
     * the token ID to the To, mark the content hash as used.
     *
     * Note that the content hash must be unique for future mints to prevent duplicate media.
     */
    function _mintTo(address to, uint256 quantity) internal 
        onlyMintAvailable
        onlyOwner
    {
        _safeMint(to, quantity);
    }

    /* *****************
     * Internal Functions
     * *****************
     */

    function _startTokenId() internal view override virtual returns (uint256) {
        return 1;
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function _baseURI() internal view override virtual returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "MediaA: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }
}
